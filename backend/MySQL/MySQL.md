



# 索引

## 1、前序知识

MySQL官网：https://dev.mysql.com/doc/





## 2、MySQL存储引擎

### MyISAM





### InnoDB

索引类型为聚簇索引（索引和详细数据放在一起）

支持事务，支持表锁，支持行锁，支持外键。

MySQL默认为InnoDB。



### MEMORY







## 3、索引是什么

索引是一种提高mysql查询效率的数据结构

索引存储在文件系统中（磁盘上），索引查找会产生磁盘IO，InnoDB磁盘预读16kb

索引文件的存储形式与存储引擎有关，

索引文件的结构是B+Tree



## 4、索引为什么用B+Tree？

为什么不用二叉树？二叉树存数据过程中深度会不断变大，虽然二叉树是O(logN)的查询，但是每次读一个结点，也就是4K（一页）的磁盘数据就是一次IO，随着树的深度越来越深时，IO次数会越来越多，产生性能瓶颈。且二叉树最差的情况，就是极度不平衡时，会退化成链表，此时查询甚至会退化成O(N)。

为什么不用二叉平衡树如红黑树？平衡二叉树也是二叉树，也会出现IO次数过多，导致性能瓶颈。

为什么不用HashMap？HashMap的原理无论在1.7之前还是之后，也会出现上诉情况。



为什么不用BTree？B树所有的键值分别在各个节点（4K或4k整数倍）中。在数据值非常大时，B树的深度非常大，性能低。**且B树的范围查找是通过中序遍历实现的**

![image-20221120132033919](https://richdogepic.oss-cn-hangzhou.aliyuncs.com/img/202211201320090.png) 



为什么B+Tree就可以？因为B+树每个节点只存key和索引指针。叶子节点存真正的key和data。而且叶子节点之间形成链式环结构，因此可以进行两种查找运算：一种从根节点自上而下的进行查找，另一种就是通过由叶子结点组成的链表进行查找。

- B+树的磁盘读写代价更低
  　　B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。**一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了；**
- B+树查询效率更加稳定
  　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。**所以任何关键字的查找必须走一条从根结点到叶子结点的路。**所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；
- B+树便于范围查询（最重要的原因，范围查找是数据库的常态）
  　　B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。**B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的**，而B树不支持这样的操作或者说效率太低；B树的范围查找是利用中序遍历实现的，而B+树则是利用链表实现的。


![image-20221120135237361](https://richdogepic.oss-cn-hangzhou.aliyuncs.com/img/202211201352555.png)







## 5、索引的类型

- 主键索引：主键是唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键
- 唯一索引：索引列的所有值只能出现一次，即必须唯一，值可以为空，UNIQE
- 普通索引：基本索引类型，值可以为空，没有唯一性约束
- 组合索引：多个值组成一个索引，适合多表联查
- 全文索引：用的少，FULLTEXT。





## 6、索引失效































# 事务

## 1、事务的隔离级别

**事务有四大特点**：ACID，原子性、一致性、隔离性、持久性

- 原子性是通过 undo log（回滚日志） 来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
- 持久性是通过 redo log （重做日志）来保证的；



**并行事务会引发三大问题**：脏读 > 不可重复读 > 幻读。脏读的问题最严重。



**MySQL提供的隔离级别有四种**：读未提交 < 读提交 < 可重复读 < 串行化。隔离级别越高、性能效率就越低



**隔离级别对应存在的并发问题及解决方式**

- 读未提交会出现**脏读**

脏读：当前事务A可以读到其他事务B未提交的数据。如果在事务提交前，其他事务不能读修改过的数据即可解决。

解决方式：将隔离级别设置为读提交



- 读提交会出现**不可重复读**

不可重复读：事务A先后两次**读同一个数据**，但在间隔期间，其他事务修改并提交了数据，导致得**到不同的结果**。与脏读的区别在于，脏读是读取的其他事务未提交的数据，不可重复读是读的其他事务提交的数据。

解决方式：只有在修改事务完全提交之后，才允许读取数据，即可重复读。



- 可重复读会导致**幻读**

幻读：一个事务的操作会导致另一个事务前后两次查询出来**符合条件的的记录数**不同。与不可重复读的区别是，不可重复读是查询的同一数据前后两次不一样，幻读是按同一条件查两次，符合的记录数不一样。

解决方式：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题，即串行化。



- 串行化效率低

对于串行化隔离级别的事务来说，通过加读写锁的方式来避免并行访问；阻塞时间很长，会大大降低访问的性能。



![image-20221120225109216](https://richdogepic.oss-cn-hangzhou.aliyuncs.com/img/202211202251409.png) 







**MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，可以避免多数幻读问题，但不能完全解决**。

通常使用两种方式来解决幻读：

1. **如果是快照读（普通select语句），是如何避免幻读的？**

可重复读隔离级是由 **MVCC（多版本并发控制）**实现的。

实现的方式是启动事务后，在执行第一个查询语句后，会创建一个 Read View（快照），后续的查询语句都是利用这个 Read View找到初始数据，所以每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，页是查询不出来这条新数据的，所以就很好了避免幻读问题。



2. **如果是当前读（select ... for update，以及除了select以外的 update、insert、delete），是如何避免幻读的？**

Innodb 引擎使用`next-key lock`**间隙锁+记录锁**解决幻读。

如果事务A执行`select name from t_person where age > 20 for update`，即给查出来的数据加上锁，等事务自动提交后锁才被释放。悲观锁。那么就会给`t_person`表中age范围是(20,+∞)的整行数据加`next-key lock`**行锁**。

此时事务B执行`insert into t_person values("李飞",24)`，就会发现插入位置被别人加了`next-key lock`，没办法继续执行。所以会在此处等待，直到事务A释放锁。

这就避免了由于事务 B 插入新记录而导致事务 A 发生幻读的现象。



3. 仍然避免不了幻读的例子





**「读提交」和「可重复读」的实现原理对比**

都是通过 **Read View **实现。但它们创建Read View的时机不同。Read View是一个数据快照，就像拍照，定格某一时刻的风景。

**读提交**是在每个语句执行前都会重新生成一个 Read View，**可重复读**是「启动事务」时生成Read View，整个事务期间都在用这个快照。

>注意，执行「开始事务」命令，**并不意味**着启动了事务。在 MySQL 有两种开启事务的命令，分别是：
>
>- 第一种：begin/start transaction；
>- 第二种：start transaction with consistent snapshot；
>
>这两种命令，事务的启动时机是不同的：
>
>- 执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；
>- 执行了 start transaction with consistent snapshot 命令，**就会马上启动事务。**







































